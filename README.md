## Задание 1 ✅
Есть три типа контрактов:  
- Контракт на мобильную связь;
- Контракт на проводной интернет;
- Контракт на цифровое телевидение.  

Все типы контрактов имеют поля:
- ID;
- Дата начала контракта;
- Дата окончания контракта;
- Номер контракта;
- Владелец контракта (Сущность Человек).  

Кроме того:  
- Контракт на мобильную связь имеет свойства(количество минут, смс и Гб трафика);
- Контракт на проводной интернет - скорость соединения;
- Контракт на цифровое телевидение - пакет каналов.  

Сущность Человек имеет свойства:  
- ID;
- Фамилия Имя Отчеcтво;
- Дата рождения;
- Пол;
- Серия и номер паспорта;
- Вычисляемое свойство - возраст.  

Необходимо создать репозиторий, который позволял бы хранить контракты этих типов. Репозиторий должен позволять добавлять произвольное количество контрактов, удалять контракты по ID, получать контракты по ID.
В этом задании нельзя использовать встроенные коллекции. Репозиторий должен быть создан на основе массива, с использованием механизма расширения, который будет вызываться, если места для добавления не хватает.

## Задание 2 ✅
- Добавить возможность поиска по репозиторию по различным критериям. Нужно определить метод, который бы принимал в качестве параметра критерии поиска и возвращал результаты поиска по этим критериям. Критерии поиска передаются через предикаты(см. класс Predicate). Результатом поиска будет объект класса вашего репозитория.  

- Добавить возможность сортировки по различным критериям:
Нужно описать интерфейс ISorter который будет содержать метод sort принимающий, в том числе, компаратор.  
Нужно описать несколько классов-имлементаций этого интерфейса(например BoubleSorter, MergeSorter или типа того).  
Далее, использовать эти классы для сортировки в репозитории.  
Важный момент: критерий сортировки должен передаваться через компараторы(см. класс Comparator).

## Задание 3 ✅
Дан csv-файл, который содержит информацию о контрактах. Список полей вы определяете исходя из своей модели. Например:  

##### ДатаНачалаКонтракта; ДатаКонцаКонтракта; ФИОКлинета;ПолКлиента;ДатаРождения;ДанныеПаспорта;ТипКонтракта;ДопИнформацияПоКонтракту;  

Предпоследнее поле определяет тип контракта (мобильный, тв или интернет).  

Последнее поле содержит в себе специфичную для каждого типа контракта информацию. Например для мобильного контракта там находится информация о тарифном плане(минуты, гигабайты, смс). Для ТВ - кпакет каналов и т.д.  

Нужно написать класс, добавляющий данные из этого файла в ваш репозиторий. Т.е. должен быть некий класс-загрузчик, который на вход принимает файл и репозиторий и добавляет информацию из этого файла в ваш репозиторий.  

Для чтения из файла можно использовать либо стандартные бибилотеки Java IO (см. FileReader и BufferReader) или специальную библитеку(например opencsv).

## Задание 4 ✅
Разработать механиз валидации контракта.  
Для этого необходимо создать классы которые могли бы проверять переданный им в качестве параметра контракт и возвращать в качестве результата объект, содержащий информацию о результатате проверки. Результат проверки должен содержать:  
- Статус проверки (например, ок, error, red risk и т.п.);  
- Некий текст, описывающий ошибку (если она есть);  
- Далее, опционально на ваше усмотрение (например, можно возвращать имя поля, в котором была найдена ошибка).  
Добавить использование валидаторов в класс загрузчик CSV.


## Задание 5 ✅
Рефлексия и DI  
1. Создать аннотацию AutoInjectable (или любое другое название). Данной аннотацией будут помечаться поля классов для которых нужно будет осуществить внедрение зависимости;  
2. Создать аннотацию Configuration (или любое другое название) со свойством packages (массив String). Данное свойство будет хранить в себе имена пакетов, где нужно будет искать классы, инстансы которых будут внедряться в поля, помеченные аннотацией AutoInjectable;  
3. Создать класс Injector (или любое другое имя), который будет осуществлять внедрение зависимостей.  
- Данный класс помечаем аннотацией Configuration. По ее свойству packages определяем в каких пакетах будем искать классы;  
- Создаем метод что-то типа public static <T> T inject(T object){...}.  
  
В этот метод будет передаваться некий объект куда надо осуществить внедрение зависимостей. В теле метода:  
1. Ищем поля класса, которые помечены аннотацией AutoInjectable;  
2. Если это простое поле (не коллекция) то ищем класс, среди пакетов, которые указаны в конфигурации, который может быть внедрен (совпадают интерфейсы, или наследники или еще что - правило по которому ищется класс можете придумать сами). Если таких классов больше одного - выкидываете исключение. Если таких классов нет - выкидываете исключение. Если такой класс один - создаете экземпляр и внедряетет его в поле;  
3. Если поле типа коллекции, то тогда делаем тоже, что и в пункте два, только без проверки на количество классов (сколько нашли, столько и внедрили в коллекцию).  
Протестировать инъекцию на классе репозитории (пометив поле сортировщика(sorter) аннотацией AutoInjectable) и на CSV loader пометив этой аннотацией поле со списком валидаторов.  

## Задание 6 ✅ [(В отдельном репозитории)](https://github.com/reemake/multithreaded-matrix-multiplication)
Реализовать перемножение двух матриц в многопоточном режиме.  

Нужно написать класс, который бы мог осуществлять такое перемножение. На вход ему подаются две матрицы. На выходе - результат перемножения. Особое внимание тут нужно обратить на то, какую именно часть работы вы будете выполнять в каждом потоке и, что если будете создавать тысячи потоков, каждый из которых будет считать только одну ячейку, то это крайне не эффективно.
  
## Задание 7 ✅ [(В отдельном репозитории)](https://github.com/reemake/bank-system-multithreading)
  
Необходимо написать программу, моделирующую работу банка. Для этого надо описать следующие классы:  

1. **Касса банка**  

Предполагается, что наш банк работает только с наличностью, поэтому все клиенты, приходящие в банк, по сути, работают с одним и тем же счетом - кассой наличных денег.

2. **Клиент банка**  

Сущность, появляющаяся в случайные моменты времени во время работы программы. Обладает следующими свойствами: Вид операции (снять деньги/положить деньги, сумма операции, время обслуживания (см. ниже)). Свойства генерируются случайным образом при появлении объекта.

3. **Операционист**  

Сущность, которая проводит обслуживание клиентов. Каждый операционист - это, по сути, отдельный поток, который запускается вместе с началом работы банка. Операционист имеет непосредственный контакт с кассой и именно операционист, по сути, выполняет снятие или пополнение кассы. У каждого операциониста есть своя очередь клиентов, которых он должен обслужить (т.е. очередь не общая).

4. Дополнительные классы типа: **Генератор клиентов**, сам **банк** и т.п.  

Ход работы программы:  

При запуске программы создается касса с неким начальным количеством денег и **N** операционистов. Так же запускается специальный поток - генератор клиентов. Он создает объекты клиентов в случайные моменты времени и направляет их в очередь к одному из операционистов. В качестве операциониста выбирается тот, у кого в очереди меньше всего объектов.  

Операционист производит обслуживание следующим образом:  

1. Если в очереди никого нет, то ждем пока там кто-то появится (именно ждем, а не просто спим).

2. Если появился клиент, то мы смотрим, на тип операции и на количество денег. Если операция "положить", то ее выполняем без проверок. если снять - то проверяем, есть ли в кассе деньги. если денег нет, то отказываем клиенту в обслуживании и либо просто его удаляем, либо отправляем в некую специальную очередь ожидающих денег. Если мы можем выполнить операцию (клиент кладет деньги или в кассе есть деньги, чтобы отдать их клиенту) то операционист выполняет операцию столько времени, сколько в свойстве "время обслуживания" у клиента (т.е. по сути, операционист, как поток, засыпает на это время). При этом к нему в очередь в этот момент времени другие клиенты могут становиться.  

Все операции (типа клиент появился, клиент положил или снял деньги на счет) имеют трассировку на экран или в лог.  

В итоге, мы запускаем программу и смотрим что у нас происходит в банке.  

В качестве констант, рекомендую вынести:

- **N** - количество операционистов;

- **SERVICE_TIME** - среднее время обслуживание;

- **CLIENTS_PER_MINUTE** - среднее количество клиентов в минуту.

Последние две будут базой для генерации времени обслуживания клиента и времени через который будет появляться новый клиент.
  
## Задание 8 ✅
Добавить возможность сохранение и восстановления репозитория контрактов с использование JDBC.
  
## Задание 9 ✅
Добавить возможность сохранение и восстановления репозитория контрактов с использование JAXB.
